var documenterSearchIndex = {"docs":
[{"location":"background/signaling_dimension/#Signaling-Dimension","page":"Signaling Dimension","title":"Signaling Dimension","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The signaling dimension specifies the amount of classical communication needed to exactly simulate a channel provided an unlimited amount of shared randomness.   The signaling dimension was originally introduced for generalized probability theories [DallArno2017], while a similar quantity has also been discussed without the use of shared randomness [Heinosaari2020]. As it turns out, shared randomness is an important resource for simulating quantum systems as there exist qubit system that cannot be simulated by a single bit of classical communication, but require shared randomness to perform the simulation [deVicente2017].","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"note: Note:\nSignalingDimension.jl considers the signaling dimension of signaling devices that have classical inputs and outputs (see Signaling Correlations). The signaling dimension can be certified for quantum and classical signaling systems alike.","category":"page"},{"location":"background/signaling_dimension/#Definition","page":"Signaling Dimension","title":"Definition","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The signaling dimension is denoted by kappa(cdot) and can be defined for a fixed signaling device and general channels alike.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Given the signaling correlations mathbfPinmathcalP^X to Y the signaling dimension kappa(mathbfP) is defined as the smallest integer d such that mathbfP in mathcalC_d^X to Y.\nGiven a quantum channel mathcalN the signaling dimension kappa(mathcalN) is the smallest integer d such that mathcalQ_mathcalN^Xto YsubsetmathcalC_d^Xto Y for any choice of numbers of classical inputs X and outputs Y.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The  signaling dimension is defined with respect to the observed signaling correlations and requires no assumptions to be made about the communication process. Hence the signaling dimension is a device-independent metric. The signaling dimension of quantum channels is elaborated upon in Certifying the Classical Simulation Cost of a Quantum Channel.","category":"page"},{"location":"background/signaling_dimension/#Classical-Simulation-Cost","page":"Signaling Dimension","title":"Classical Simulation Cost","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The signaling dimension specifies the minimum amount of classical communication d needed to simulate a quantum channel mathcalN as simply d=kappa(mathcalN). A priori, there is little indication of whether classical dit communication with shared randomness is capable of simulating qudit communication. However, this is the case indeed. A fundamental limit of quantum information is described by Holevo's Theorem [Holevo1973] which states that the classical capacity of a quantum channel cannot exceed that of a noiseless classical channel of the same dimension d. While Holevo's bound only holds when considering many uses  of the channel, it was recently shown that this limit holds in the one-shot communication setting as well. That is, the set of noiseless quantum channels mathcalQ_d^X to Y with Hilbert space dimension d is contained by the set of noiseless classical channels mathcalC_d^X to  Y and textConv(mathcalQ_d^X to Y) = mathcalC_d^X to  Y[Frenkel2015] where textConv(cdot) is the convex hull. This result is remarkable because  it implies that kappa(textid_d) = d; that is, one dit of classical communication and shared randomness can exactly simulate any quantum channel of d dimensions.","category":"page"},{"location":"background/signaling_dimension/#Significance","page":"Signaling Dimension","title":"Significance","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"As a device-independent metric of the classical simulation cost, the signaling dimension has broad applications in quantum  technology. Namely, the signaling dimension can be certified for any quantum computing, memory, or communication device that process classical information. Hence a direct comparison between quantum and classical resources is established. That is,","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"    textquditsubset textdit + textshared randomness","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Since the statistics of a quantum system and its classical simulation are indistinguishable such signaling devices are considered to be operationally equivalent. Therefore, the classical simulation cost can help justify (or reject) the use of quantum technology for a particular task.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"note: Note:\nCertain fundamental quantum properties such as no-cloning or non-locality cannot be simulated classically. These properties are not reflected in the signaling correlations. To observe these phenomena additional assumptions must be made.","category":"page"},{"location":"background/signaling_dimension/#Certification","page":"Signaling Dimension","title":"Certification","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Certifying the signaling dimension of classical and quantum channels requires one to verify whether or not mathbfPinmathcalC_d^X to Y. In general, this is a challenging task and can only be done with certainty in special cases. The SignalingDimension.jl package provides tools that assist the certification of signaling dimension. We elaborate on these certification procedures in the Certifying Signaling Dimension section.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"In principle, the signaling dimension can be witnessed by the Bell inequalities that tightly bound the set mathcalC_d^Xto Y. These Bell inequalities are discussed further in the Bell Inequalities section. Note however that Bell inequality computations rapidly become infeasible. As a result, one should only expect to find lower and upper bounds for the signaling dimension of a particular system.","category":"page"},{"location":"background/signaling_dimension/#References","page":"Signaling Dimension","title":"References","text":"","category":"section"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[DallArno2017]: Dall’Arno, Michele, et al. \"No-hypersignaling principle.\" Physical review letters 119.2 (2017): 020401.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[Heinosaari2020]: Heinosaari, Teiko, Oskari Kerppo, and Leevi Leppäjärvi. \"Communication tasks in operational theories.\" Journal of Physics A: Mathematical and Theoretical 53.43 (2020): 435302.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[deVicente2017]: de Vicente, Julio I. \"Shared randomness and device-independent dimension witnessing.\" Physical Review A 95.1 (2017): 012340.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[Holevo1973]: Holevo, Alexander Semenovich. \"Bounds for the quantity of information transmitted by a quantum communication channel.\" Problemy Peredachi Informatsii 9.3 (1973): 3-11.","category":"page"},{"location":"background/signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[Frenkel2015]: Frenkel, Péter E., and Mihály Weiner. \"Classical information storage in an n-level quantum system.\" Communications in Mathematical Physics 340.2 (2015): 563-574.","category":"page"},{"location":"background/signaling_polytopes/#Signaling-Polytopes","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Let mathcalC_d^Xto Y denote the  set of classical signaling correlations produced using one-way, noiseless classical communication and shared randomness. This set is a convex polyhedron that we refer to as the signaling polytope. As a convex polyhedron, the signaling polytope mathcalC_d^X to Y admits two equivalent descriptions[Ziegler2012]:","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Vertex Description: Let mathcalV_d^Xto YsubsetmathcalC_d^Xto Y   denote the set of signaling polytope vertices.   Then, the signaling polytope is defined as the convex-hull of its vertices mathcalV_d^Xto Y,","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"    mathcalC_d^X to Y = textConv(mathcalV_d^X to Y)","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Half-Space Description: Let mathcalF_d^X to Y denote the set of   closed half-space inequalities on mathbbR^Y times X that tightly bound   the signaling polytope mathcalC_d^Xto Y.   We  refer to an inequality in mathcalF_d^X to Y as a facet. Then, the signaling   polytope is defined as the intersection of all inequalities in mathcalF_d^Xto Y,","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"    mathcalC_d^Xto Y = capmathcalF_d^X to Y","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The BellScenario.LocalPolytope module provides tools for computing each of these representations.","category":"page"},{"location":"background/signaling_polytopes/#Vertices","page":"Signaling Polytopes","title":"Vertices","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"A signaling polytope vertex mathbfVinmathcalV_d^X to Y must satisfy:","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Elements V(yx) in 01 for all yinmathcalY and xinmathcalX\ntextRank(mathbfV) leq d","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The total number of vertices in mathcalV_d^X to Y is then counted by [DallArno2017]","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"mathcalV_d^X to Y = sum_c=1^d leftX atop c rightbinomYcc","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"where  denotes Stirling's number of the second kind and binomYc denotes Y choose c.","category":"page"},{"location":"background/signaling_polytopes/#Code-Example:-Counting-Vertices","page":"Signaling Polytopes","title":"Code Example: Counting Vertices","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Signaling polytope vertices can be counted using the BellScenario.LocalPolytope.num_vertices method.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"using BellScenario\n\nX = 4    # num inputs\nY = 4    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Count the number of vertices for the signaling polytope\nnum_vertices = LocalPolytope.num_vertices(scenario)","category":"page"},{"location":"background/signaling_polytopes/#Code-Example:-Enumerating-Vertices","page":"Signaling Polytopes","title":"Code Example: Enumerating Vertices","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The set of vertices mathcalV_d^X to Y can be enumerated  using the BellScenario.LocalPolytope.vertices method. Since vertices have 0/1 elements, they can be represented by BellScenario.DeterministicStrategy.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"note: Vertex Normalization\nThe columns of a channel mathbfPinmathcalP^X to Y are normalized such that sum_y=1^Y P(yx) = 1 for all x. Therefore, mathbfP can be represented in a \"normalized\" subspace where the Y-th row of matrix mathbfP is removed.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"note: Vectorization\nThe polytope transformation software used by the BellScenario.LocalPolytope module requires vertices to be represented as vectors. Hence a column-major vectorization is used both vertices and facets in the polytope computations.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"using BellScenario\n\nX = 4    # num inputs\nY = 4    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\n# These vertices can be fed directly into polytope transformation methods.\nvertices = LocalPolytope.vertices(scenario)\n\n# Convert each vertex into a `DeterministicStrategy` matrix form.\ndeterministic_strategies = map(v -> convert(DeterministicStrategy, v, scenario), vertices)","category":"page"},{"location":"background/signaling_polytopes/#Facets","page":"Signaling Polytopes","title":"Facets","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Let the tuple (mathbfGgamma) in mathcalF_d^X to Y designate a facet of mathcalC_d^X to Y where mathbfGin mathbbR^Ytimes X and gammain mathbbR. The half-space inequality is then expressed as","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"gamma geq langle mathbfG mathbfPrangle = sum_xyG_yxP(yx)","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"where langlemathbfGmathbfPrangle is the Euclidean inner product with some matrix mathbfPinmathcalP^Xto Y. A facet (mathbfGgamma)inmathcalF_d^X to Y must satisfy:","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"gamma geq langle mathbfG mathbfV rangle for all vertices mathbfV in mathcalV_d^X to Y.\ngamma = langle mathbfG mathbfV rangle for at least X(Y-1) affinely independent vertices mathcalV_d^X to Y.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"A facet inequaliity (mathbfGgamma)inmathcalF_d^X to Y tightly bounds the signaling polytope mathcalC_d^Xto Y, therefore, if gamma ngeq langlemathbfGmathbfPrangle, then mathbfPnotinmathcalC_d^X to Y. Hence the inequalities (mathbfGgamma)inmathcalF_d^X to Y can verify whether a channel mathbfPinmathcalP^Xto Y is also contained by the signaling polytope mathcalC_d^X to Y. Within the context of Bell scenarios, these facets are referred to as tight Bell inequalities and are discussed in greater detail in the Bell Inequalities section.","category":"page"},{"location":"background/signaling_polytopes/#Code-Example:-Complete-Facet-Enumeration","page":"Signaling Polytopes","title":"Code Example: Complete Facet Enumeration","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"A facet inequality is represented by the  BellScenario.BellGame type. Note however, that the polytope computation software represents  mmatrix mathbfG with a column-major vectorization in the normalized subspace.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"note: Facet Normal Form\nFor any half-space inequality (mathbfGgamma),  gamma and mathbfG are not unique. Therefore, a normal form must be established for facets. The normal form used in this work is as follows:     1. The elements of matrix mathbfG are non-negative integers and     2. The corresponding bound gamma is a non-negative integer.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"warning: Performance of Facet Computations\nFacet computations fail to perform for large numbers of vertices and vertices with large dimension. The number of vertices scale exponentially with the number of inputs and outputs, while the dimension scales as X(Y-1).","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\nvertices = LocalPolytope.vertices(scenario)\n\n# Compute complete set of facets in \"normalized\" subspace.\nfacets = LocalPolytope.facets(vertices)[\"facets\"]\n\n# Convert each facet into `BellGame` form.\nbell_games = map( f -> convert(BellGame, f, scenario), facets)\n\n# printing γ ≥ G for each bell game\nfor bg in bell_games\n    println(bg.β, \" ≥ \", bg.game)\nend","category":"page"},{"location":"background/signaling_polytopes/#Adjacency-Decomposition","page":"Signaling Polytopes","title":"Adjacency Decomposition","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The values of input x and output y for a signaling scenario are merely labels. Rearranging these labels cannot change the structure of the signaling polytope. Hence the signaling polytope is invariant under permutations of inputs and outputs[Rosset2014]. This permutation symmetry results in a transitivity of vertices and facets. That is, any permutation of a vertex (or facet) is also  a vertex (or facet) of mathcalC_d^X to Y. Furthermore, we define a vertex class (facet class) as the set of all vertices (facets) generated by taking row/column permutations. Hence, there exists a canonical set of generator vertices and facets whose permutations describe the complete set of signaling polytope facets mathcalF_d^X to Y. Since the number of permutations scale as (X) and (Y), the set of generators is dramatically reduces in the total number vertices and facets needed to describe the polytope.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"Given  the permutation symmetry of singaling polytopes, the adjacency decomposition technique [Christof2001] is an effective algorithm for computing the generator facets of a convex polytope. Key advantages of the adjacency decomposition technique include:","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The complete set of facets does not need to be stored in memory, only the generator facets.\nIf not run to completion, a partial list of generator facets is obtained.\nThe computation can be widely parallelized.","category":"page"},{"location":"background/signaling_polytopes/#Code-Example:-Adjacency-Decomposition","page":"Signaling Polytopes","title":"Code Example: Adjacency Decomposition","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"The adjacency decomposition greatly reduces facet computation times and can be performed on signaling polytopes using the BellScenario.LocalPolytope.adjacency_decomposition method. Please refer to BellScenario.jl documentation for additional details on the arguments, outputs, and implementation of the adjacency decomposition algorithm.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"note: Lexicographic Normal Form\nThe generator facet for a facet class is arbitrary. Therefore, we establish a lexicographic ordering for each permutation in a facet class. The facets computed by BellScenario.LocalPolytope.adjacency_decompostion are presented in their lexicographic normal form which is maximal in the lexicographic ordering of the facet class.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"using BellScenario\n\nX = 6    # num inputs\nY = 4    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\nvertices = LocalPolytope.vertices(scenario)\n\n# The adjacency decomposition requires a facet to seed the algorithm.\nfacet_seed = BellGame([1 0 0 0 0 0;0 1 0 0 0 0;0 0 1 0 0 0;0 0 0 1 0 0], 2)\n\n# Compute the complete set of generator facets\nadj_dict = LocalPolytope.adjacency_decomposition(vertices, facet_seed, scenario)\n\n# The generator facets are the keys of returned dictionary\nfor bell_game in keys(adj_dict)\n    println(bell_game.β, \" ≥ \", bell_game.game, \"\\n\")\nend","category":"page"},{"location":"background/signaling_polytopes/#References","page":"Signaling Polytopes","title":"References","text":"","category":"section"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"[Ziegler2012]: Ziegler, Günter M. Lectures on polytopes. Vol. 152. Springer Science & Business Media, 2012.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"[DallArno2017]: Dall’Arno, Michele, et al. \"No-hypersignaling principle.\" Physical Review Letters 119.2 (2017): 020401.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"[Rosset2014]: Rosset, Denis, Jean-Daniel Bancal, and Nicolas Gisin. \"Classifying 50 years of Bell inequalities.\" Journal of Physics A: Mathematical and Theoretical 47.42 (2014): 424022.","category":"page"},{"location":"background/signaling_polytopes/","page":"Signaling Polytopes","title":"Signaling Polytopes","text":"[Christof2001]: Christof, Thomas, and Gerhard Reinelt. \"Decomposition and parallelization techniques for enumerating the facets of combinatorial polytopes.\" International Journal of Computational Geometry & Applications 11.04 (2001): 423-437.","category":"page"},{"location":"certifying_signaling_dimension/#Certifying-Signaling-Dimension","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"Formally, certifying the signaling dimension requires that a channel mathbfPinmathcalP^X to Y is checked against all tight Bell inequalities bounding the signaling polytopes. In general cases, it is difficult derive these Bell inequalities and test them all. Despite this challenge, the signaling dimension can be bounded. We now provide methods that efficiently compute upper and lower bounds on the signaling dimension. For more details please refer to our work Certifying the Classical Simulation Cost of a Quantum Channel.","category":"page"},{"location":"certifying_signaling_dimension/#Bounds","page":"Certifying Signaling Dimension","title":"Bounds","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"In most cases, it is not feasible to compute the exact signaling of a channel, however, loose lower and upper bounds can be determined with efficiency.","category":"page"},{"location":"certifying_signaling_dimension/#Lower-Bounds","page":"Certifying Signaling Dimension","title":"Lower Bounds","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"maximum_likelihood_lower_bound\nambiguous_lower_bound","category":"page"},{"location":"certifying_signaling_dimension/#SignalingDimension.maximum_likelihood_lower_bound","page":"Certifying Signaling Dimension","title":"SignalingDimension.maximum_likelihood_lower_bound","text":"maximum_likelihood_lower_bound( P :: BellScenario.AbstractStrategy ) :: Int64\n\nUses maximum likelihood estimation to efficiently compute the lower bound of the signaling dimension. For a channel mathbfPinmathcalP^X to Y, the maximum likelihood lower bound on the signaling dimension is expressed,\n\nkappa(mathbfP) geq sum_yinY max_xinX P(yx)\n\nSince the maximum_likelihood_facet is present on all signaling polytopes, a lower bound can always be found with efficiency.\n\n\n\n\n\n","category":"function"},{"location":"certifying_signaling_dimension/#SignalingDimension.ambiguous_lower_bound","page":"Certifying Signaling Dimension","title":"SignalingDimension.ambiguous_lower_bound","text":"ambiguous_lower_bound( P :: BellScenario.AbstractStrategy ) :: Int64\n\nReturns the lower bound on the signaling dimension as witnessed by family of ambiguous_guessing_game Bell inequalities. The intersection of the family of ambiguous guessing games forms the ambiguous polytope mathcalA_kd^Xto Y where a violation to this polytope means that kappa(mathbfP) geq d. Hence this method  computes the smallest d such that mathbfPinmathcalA_kd^Xto Y for all k. Formally, the  following equality is violated if mathbfPnotinmathcalA_kd^X to Y\n\nd geq max_kinYmax_sigmain Omega_Y sum_y=1^k max_xinX P(sigma(y)x) + frac1X - d + 1sum_y=k+1^Ysum_xin n P(sigma(y)x)\n\nwhere Omega_Y is the set of all permutations of Y.\n\n!!! \"note\" Note:     Considering all permutations of k guessing rows can be costly. This performance     is greatly improved by sorting the rows of mathbfP by their difference     max(row...) - sum(row)/(X - d + 1) in non-increasing order.\n\nIn general, it may not be necessary to consider the entire range of k. For more specialized cases we provide the following methods:\n\n\n\n\n\nambiguous_lower_bound(\n    P :: BellScenario.AbstractStrategy,\n    k :: Int64\n) :: Int64\n\nFinds the ambiguous lower bound on kappa(mathbfP) for fixed k.\n\nP - Channel mathbfPinmathcalP^Xto Y, a column stochastic matrix.\nk - The number of guessing rows.\n\nA DomainError is thrown if:\n\nk < 1\nk > size(P)[1] (number of rows in P).\n\n\n\n\n\nambiguous_lower_bound(P :: BellScenario.Strategy, k_range :: UnitRange{Int64}) :: Int64\n\nReturns the smallest integer d such that P is contained by all ambiguous polytopes with k in k_range.\n\nA DomainError is thrown if k_range is not contained by the range [1:size(P,1)].\n\n\n\n\n\n","category":"function"},{"location":"certifying_signaling_dimension/#Upper-Bounds","page":"Certifying Signaling Dimension","title":"Upper Bounds","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"trivial_upper_bound\nattains_trivial_upper_bound\nupper_bound","category":"page"},{"location":"certifying_signaling_dimension/#SignalingDimension.trivial_upper_bound","page":"Certifying Signaling Dimension","title":"SignalingDimension.trivial_upper_bound","text":"trivial_upper_bound( P :: BellScenario.AbstractStrategy ) :: Int64\n\nThe signaling dimension of channel cannot exceed the number of inputs or outputs. Therefore, the trivial upper bound for the signaling dimension of a channel mathbfPinmathcalP^X to Y is simply,\n\nkappa(mathbfP) leq minXY\n\n\n\n\n\n","category":"function"},{"location":"certifying_signaling_dimension/#SignalingDimension.attains_trivial_upper_bound","page":"Certifying Signaling Dimension","title":"SignalingDimension.attains_trivial_upper_bound","text":"attains_trivial_upper_bound( P :: BellScenario.Strategy ) :: Bool\n\nReturns true if the channel P attains the trivial_upper_bound. This method relies on the fact:\n\nWhen d = X - 1, the signaling polytope mathcalC_d^X  to Y is only   bound by maximum likelihood facets.\nWhen d = Y - 1, the  signaling polytope mathcalC_d^X to Y is only   bound by maximum likelihood and ambiguous facets.\n\n\n\n\n\n","category":"function"},{"location":"certifying_signaling_dimension/#SignalingDimension.upper_bound","page":"Certifying Signaling Dimension","title":"SignalingDimension.upper_bound","text":"upper_bound( P :: BellScenario.AbstractStrategy ) :: Int64\n\nReturns an upper bound for the signaling dimension of a channel P. If attains_trivial_upper_bound returns true, then this upper bound is tight and designates the signaling dimension. Otherwise, a loose upper bound is provided. A lower bound can be found with the maximum_likelihood_lower_bound or ambiguous_lower_bound methods.\n\n\n\n\n\n","category":"function"},{"location":"certifying_signaling_dimension/#Quantum-Channel-Certification","page":"Certifying Signaling Dimension","title":"Quantum Channel Certification","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"The signaling dimension is a device-independent metric which can be applied to quantum and classical channels alike. To certify a quantum channel, the signaling correlations must first be obtained. This can be done by selecting a set of input states Psi = rho_x_xinmathcalX and using semi-definite programming to optimize the POVM. The objective function of the optimization is expressed as a BellScenario.BellGame.","category":"page"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"The BellScenario.Nonlocality module performs the POVM optimization.","category":"page"},{"location":"certifying_signaling_dimension/#Code-Example:-Optimizing-Quantum-Measurements-Against-Maximum-Likelihood-Game","page":"Certifying Signaling Dimension","title":"Code Example: Optimizing Quantum Measurements Against Maximum Likelihood Game","text":"","category":"section"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"using BellScenario\nusing QBase\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # qudit\n\nscenario = LocalSignaling(X, Y, d)\n\n# maximum likelihood game for the scenario\nfacet = BellGame([1 0 0;0 1 0;0 0 1], 2)\n\nΨ = States.trine_qubits\n\n# performing semi-definite programming to find optimal POVM\noptimization_dict = Nonlocality.optimize_measurement(scenario, facet, Ψ)","category":"page"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"The output dictionary contains useful information regarding the optimization. The POVM can then be used to construct the quantum signaling correlations.","category":"page"},{"location":"certifying_signaling_dimension/","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"Π = Observables.POVM(optimization_dict[\"povm\"])\n\nquantum_strategy(Π, Ψ)","category":"page"},{"location":"bell_inequalities/#Bell-Inequalities","page":"Bell Inequalities","title":"Bell Inequalities","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"A linear inequality langlemathbfGmathbfPrangleleq gamma is defined as a Bell inequality of a signaling polytope mathcalC_d^X to Y if all channels mathbfPinmathcalC_d^X to Y satisfy the Bell inequality, that is,","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"    mathcalC_d^X to Ysubset mathbfPinmathcalP^X to Y langlemathbfGmathbfPrangleleq gamma ","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"A Bell inequality is  denoted by the tuple (mathbfGgamma) where mathbfGinmathbbR^Ytimes X and gammainmathbbR . It is useful to apply a game interpretation to a Bell inequality. In the case of local signaling scenarios, a Bell inequality can be interpreted as a cooperative guessing game played by Alice and Bob. In this interpretation, Alice is shown an input xinX and sends a message to Bob using a limited amount of communication. Bob then makes a guess yinY. The matrix mathbfG specifies the reward for outputting y when given input x. The objective of the game is then to score higher than gamma, that is, the objective is to violate the Bell inequality (mathbfG gammma). Hence Alice and Bob strategize their encoding and decoding schemes to maximize the reward. If they are able to score higher than gamma, then Alice and Bob \"win\" the game.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"We now discuss a subset of general Bell inequalities for signaling polytopes. Further details about these inequalities are provided in Certifying the Classical Simulation Cost of a Quantum Channel.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"k_guessing_game\nambiguous_guessing_game","category":"page"},{"location":"bell_inequalities/#SignalingDimension.k_guessing_game","page":"Bell Inequalities","title":"SignalingDimension.k_guessing_game","text":"The k-guessing game is a general family of Bell inequalities for signaling polytopes. For any integer kin0Y a k-guessing game Bell inequality (mathbfG_textKgamma_textK) bounds the signaling polytope mathcalC_d^binomYkto Y . The columns of matrix mathbfG_textKin mathbfR^Y times binomYk consist of all binomYk ways to arrange k unit elements and (Y-k) null elements. Hence each input xinX corresponds to a unique set of k correct answers out of Y possible answers. The upper bound is  gamma_textK = binomYk - binomY-dk.\n\nA k-guessing game Bell inequality is constructed with the k_guessing_game method,\n\nk_guessing_game(Y :: Int64, d :: Int64, k :: Int64) :: BellGame\n\nParameters:\n\nY - The number of outputs\nd - The signaling dimension\nk - The number of unit elements in each column. Must satisfy Y ≥ k ≥ 0.\n\nFor example,\n\nusing SignalingDimension\n\nG_K = k_guessing_game(6,2,3)\n\n# output\n\n6×20 BellScenario.BellGame:\n 1  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0\n 1  1  1  1  0  0  0  0  0  0  1  1  1  1  1  1  0  0  0  0\n 1  0  0  0  1  1  1  0  0  0  1  1  1  0  0  0  1  1  1  0\n 0  1  0  0  1  0  0  1  1  0  1  0  0  1  1  0  1  1  0  1\n 0  0  1  0  0  1  0  1  0  1  0  1  0  1  0  1  1  0  1  1\n 0  0  0  1  0  0  1  0  1  1  0  0  1  0  1  1  0  1  1  1\n\nThe upper bound is then\n\nG_K.β\n\n# output\n\n16\n\nThe k_guessing_game can alternatively take a BellScenario.LocalSignaling(X, Y, d) scenario as input.\n\nk_guessing_game( scenario :: LocalSignaling, k :: Int64 ) :: BellGame\n\nA DomainError is thrown if scenario.X !=  binomial(scenario.Y, k).\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.ambiguous_guessing_game","page":"Bell Inequalities","title":"SignalingDimension.ambiguous_guessing_game","text":"Ambiguous guessing games are a family of Bell inequalities for signaling polytopes. An ambiguous guessing game, denoted by (mathbfG_textQgamma_textQ), bounds the signaling polytope mathcalC_d^X to Y. The Y times X matrix mathbfG_textQ is described as having two types of rows:\n\nGuessing Rows: one column contains a non-zero element of value (X - d + 1);\nAmbiguous Rows: each column contains a 1.\n\nFor any integer k in 0Y An ambiguous guessing game is defined to have k guessing rows and (Y-k) ammbiguous rows. The upper bound on the  ambiguous guessing game Bell inequality is then gamma_textQ = d(X-d+1).\n\nThe ambiguous_guessing_game method constructs an ambiguous guessing game Bell inequality with k guessing rows.\n\nambiguous_guessing_game(X::Int64, Y::Int64, d::Int64, k::Int64) :: BellGame\n\nParameters:\n\nX - The number of inputs\nY - The number of outputs\nd - The signaling dimension\nk - Th number of guessing rows. Must satisfy Y ≥ k ≥ 0.\n\nFor example, the following constructed ambiguous guessing game has four guessing rows and  3 ambiguous rows.\n\nusing SignalingDimension\n\n(X, Y, d) = (6, 7, 3)\n\nk = 4        # num guessing rows\n\nG_Q = ambiguous_guessing_game(X, Y, d, k)\n\n# output\n\n7×6 BellScenario.BellGame:\n 4  0  0  0  0  0\n 0  4  0  0  0  0\n 0  0  4  0  0  0\n 0  0  0  4  0  0\n 1  1  1  1  1  1\n 1  1  1  1  1  1\n 1  1  1  1  1  1\n\nG_Q.β\n\n# output\n\n12\n\nAlternatively, the ambiguous_guessing_game can accept a BellScenario.LocalSignaling(X, Y, d) scenario.\n\nambiguous_guessing_game(scenario :: LocalSignaling, k :: Int64) :: BellGame\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#Tight-Bell-Inequalities","page":"Bell Inequalities","title":"Tight Bell Inequalities","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"A signaling polytope Bell inequality (mathbfGgamma) is said to be tight if it is a facet of the  mathcalC_d^X to Y signaling polytope see Facets section. Tight Bell inequalities of a signaling polytope mathcalC_d^X to Y are important because their violation witnesses the use of more than  d dit classical communication. Hence if langlemathbfGmathbfPranglenleq gamma, then mathbfPnotin mathcalC_d^X to  Y. The SignalingDimension.jl provides a catalog of tight Bell inequality which bound general signaling polytopes.","category":"page"},{"location":"bell_inequalities/#Computed-Facets","page":"Bell Inequalities","title":"Computed Facets","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"Using the adjacency decomposition technique, we've computed a broad range of signaling polytope facets. Computed facets of the signaling polytope are found in the data/ directory.","category":"page"},{"location":"bell_inequalities/#Quick-Adjacency-Decompositions","page":"Bell Inequalities","title":"Quick Adjacency Decompositions","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"In the data/quick_adjacency_decomposition/ directory, the adjacency decomposition algorithm is used to find the generating facets of the signaling polytope. The polytope computation scripts are found in the script/quick_adjacency_decomposition/ directory. They are intended to run quickly on a laptop computer.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"Data is provided in two formats:","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":".txt files are human readable\n.ieq file format readable by BellScenario.jl.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"note: Note: Filenames\nThe scripts and produced data are named as X-d-Y.jl or X-d-Y.txt. Numbers replace X, Y, and d when particular signaling polytopes are considered. If the label X, Y, or d is used, then the script runs over a range of that parameter.","category":"page"},{"location":"bell_inequalities/#Theoretical-Facets","page":"Bell Inequalities","title":"Theoretical Facets","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"The following list of Bell inequalities are proven to be tight in Certifying the Classical Simulation Cost of a Quantum Channel. Each of the following methods constructs a canonical facet for the signaling polytope mathcalC_d^X to Y. The constructed facet inequalities are represented using the BellScenario.BellGame type. All row and column permutations of facets are also facets of mathcalC_d^X to Y.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"maximum_likelihood_facet\nambiguous_guessing_facet\nanti_guessing_facet\nk_guessing_facet\ncoarse_grained_input_ambiguous_guessing_facet\nnon_negativity_facet","category":"page"},{"location":"bell_inequalities/#SignalingDimension.maximum_likelihood_facet","page":"Bell Inequalities","title":"SignalingDimension.maximum_likelihood_facet","text":"The maximum likelihood facet (mathbfG_textMLd) tightly bounds the mathcalC_d^N to N  signaling polytope for N  d  1. The matrix mathbfG_textML is a (k=1)-guessing game (see k_guessing_game), hence, mathbfG_textML=mathbbI_N the Ntimes N identity matrix. The upper bound is  d geq langle mathbfG_textML mathbfPrangle for any channel mathbfPinmathcalC_d^N to N.\n\nmaximum_likelihood_facet( N :: Int64, d :: Int64 ) :: BellGame\n\nConstruct the maximum likelihood facet for the mathcalC_d^N to N signaling polytope. Note that N specifies the number of inputs and outputs. For example,\n\nusing SignalingDimension\n\nN = 4    # number of inputs and outputs\nd = 2    # bit signaling\n\nG_ML = maximum_likelihood_facet(N, d)\n\n# output\n\n4×4 BellScenario.BellGame:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\nG_ML.β   # the upper bound\n\n# output\n\n2\n\nA DomainError is thrown if the following requirements aren't satisfied:\n\n`N > 2\nN > d > 1\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.ambiguous_guessing_facet","page":"Bell Inequalities","title":"SignalingDimension.ambiguous_guessing_facet","text":"ambiguous_guessing_facet( Y :: Int64, d :: Int64 ) :: BellGame\n\nConstructs the ambiguous guessing facet for the `\\mathcal{C}_d^{(Y-1)\\to Y} polytope. This is a special case of the [ambiguousguessinggame](@ref) whereY = X - 1`. For example,\n\nusing SignalingDimension\n\nY = 5\nd = 3\n\nG_Q = ambiguous_guessing_facet(Y, d)\n\n# output\n\n5×4 BellScenario.BellGame:\n 2  0  0  0\n 0  2  0  0\n 0  0  2  0\n 0  0  0  2\n 1  1  1  1\n\nG_Q.β\n\n# output\n\n6\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nY ≥ 4\n(Y - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.anti_guessing_facet","page":"Bell Inequalities","title":"SignalingDimension.anti_guessing_facet","text":"anti_guessing_facet( N :: Int64, d :: Int64, ε :: Int64 ) :: BellGame\n\nConstructs the anti-guessing facet of the mathcalC_d^N to N signaling polytope. Input ε sets the size of the (k=N-1)-guessing game block while the remaining unit elements are arranged along the diagonal. The upper bound of the anti-guessing game Bell inequality is gamma = varepsilon + d - 2. For example,\n\nusing SignalingDimension\n\nN = 6    # number of inputs and outputs\nd = 2    # dit signaling\nε = 4    # anti-guessing block size\n\nG_A = anti_guessing_facet(N,d,ε)\n\n# output\n\n6×6 BellScenario.BellGame:\n 0  1  1  1  0  0\n 1  0  1  1  0  0\n 1  1  0  1  0  0\n 1  1  1  0  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\nG_A.β    # upper bound\n\n# output\n\n4\n\nNote in the above example that\n\nA DomainError is thrown if the following requirements aren't satisfied:\n\nN ≥ 4\n(N - 2) ≥ d ≥ 2\n(N - d + 1) ≥ ε ≥ 3\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.k_guessing_facet","page":"Bell Inequalities","title":"SignalingDimension.k_guessing_facet","text":"k_guessing_facet( Y :: Int64, d :: Int64, k :: Int64 ) :: BellGame\n\nConstructs the k-guessing facet for the mathcalC_d^binomYkto Y signaling polytope. A k-guessing game is tight when Y = d + k. Note that k is the number of unit elements in each column.\n\nA DomainError is satisfied if the following requirements aren't satisfied:\n\nY == k + d\nY ≥ 3\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.coarse_grained_input_ambiguous_guessing_facet","page":"Bell Inequalities","title":"SignalingDimension.coarse_grained_input_ambiguous_guessing_facet","text":"coarse_grained_input_ambiguous_guessing_facet(\n    Y :: Int64,\n    d :: Int64\n) :: BellGame\n\nConstructs a canonical form for a input coarse-grained ambiguous game. For example\n\nusing SignalingDimension\n\nY = 4\nd = 2\n\nG = coarse_grained_input_ambiguous_guessing_facet(Y, d)\n\n# output\n\n4×4 BellScenario.BellGame:\n 2  0  0  0\n 0  2  0  0\n 0  0  1  1\n 1  1  1  0\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nY ≥ 4\n(Y - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.non_negativity_facet","page":"Bell Inequalities","title":"SignalingDimension.non_negativity_facet","text":"A non-negativity facet reflects the fact that P(yx) geq 0. These facets bound all signaling polytopes.\n\nnon_negativity_facet( X :: Int64, Y :: Int64 ) :: BellGame\n\nConstructs the non-negativity game for a channel with X inputs and Y outputs. For example\n\nusing SignalingDimension\n\nG = non_negativity_facet(3, 4)\n\n# output\n\n4×3 BellScenario.BellGame:\n 1  0  0\n 1  0  0\n 1  0  0\n 0  0  0\n\nG.β\n\n# output\n\n1\n\nA DomainError is thrown if X or Y is not greater than 1.\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#Verification-of-Theoretical-Facets","page":"Bell Inequalities","title":"Verification of Theoretical Facets","text":"","category":"section"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"To verify the tightness of a Bell inequality, X(Y-1) affinely independent vertices must be found to satisfy gamma = langle mathbfG mathbfV rangle. We demonstrate these enumerations for the set of facets described above. The test/unit/affinely_independent_enumerations.jl verify that each of these enumerations scale across a wide range of scenarios.","category":"page"},{"location":"bell_inequalities/","page":"Bell Inequalities","title":"Bell Inequalities","text":"aff_ind_maximum_likelihood_vertices\naff_ind_non_negativity_vertices\naff_ind_ambiguous_guessing_vertices\naff_ind_coarse_grained_input_ambiguous_guessing_vertices\naff_ind_anti_guessing_vertices\naff_ind_k_guessing_vertices","category":"page"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_maximum_likelihood_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_maximum_likelihood_vertices","text":"aff_ind_maximum_likelihood_vertices( N :: Int64, d :: Int64 ) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices that maximize the maximum_likelihood_facet.\n\nA valid input requires N > 2 and N > d > 1.\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_non_negativity_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_non_negativity_vertices","text":"aff_ind_non_negativity_vertices(\n    num_outputs :: Int64,\n    num_inputs :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of deterministic, vertices that maximize the non_negativity_facet\n\nA valid input requires N > 2 and N > d > 1.\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_ambiguous_guessing_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_ambiguous_guessing_vertices","text":"aff_ind_ambiguous_guessing_vertices(\n    N :: Int64,\n    d :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices that maximize the ambiguous_guessing_facet.\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nN ≥ 4\n(N - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_coarse_grained_input_ambiguous_guessing_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_coarse_grained_input_ambiguous_guessing_vertices","text":"aff_ind_coarse_grained_input_ambiguous_guessing_vertices(\n    n :: Int64,\n    d :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices for the coarse_grained_input_ambiguous_guessing_facet.\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nn ≥ 4\n(n - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_anti_guessing_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_anti_guessing_vertices","text":"aff_ind_anti_guessing_vertices(N :: Int64, d :: Int64, error_size :: Int64) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices for the anti_guessing_facet.\n\nValid inputs are N > 4, N-1 > d > 1, and N-d+1 ≥ error_size ≥ 3.\n\n\n\n\n\n","category":"function"},{"location":"bell_inequalities/#SignalingDimension.aff_ind_k_guessing_vertices","page":"Bell Inequalities","title":"SignalingDimension.aff_ind_k_guessing_vertices","text":"aff_ind_k_guessing_vertices(\n    N :: Int64, d :: Int64, k :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices for the k_guessing_facet.\n\nValid inputs are N ≥ 4, d ≥ 2, and k ≥ 2.\n\n\n\n\n\n","category":"function"},{"location":"background/signaling_correlations/#Signaling-Correlations","page":"Signaling Correlations","title":"Signaling Correlations","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Consider a device that has a classical input xinmathcalX=X and classical output yinmathcalY=Y where N=12cdotsN  is a finite set of positive integers. The device is assumed to be causal, i.e. the output set mathcalY is computed from the input mathcalX, however, no assumptions are made about how mathcalY is  computed  from  mathcalX. Hence this device is regarded as a black-box and this description applies to all classical technologies as well as many quantum systems used for computation and communication. Without loss of generality, any such black-box can be described as a signaling device that transmits classical information from Alice to Bob.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Signaling Black-Box)","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The signaling device is effectively a classical channel with X inputs and Y outputs, however, the signaling process that takes mathcalXto mathcalY may use non-classical physics e.g. quantum physics. Making no assumptions about the physical system inside the channel, we can characterize its behavior by the conditional probabilities P(yx). We refer to these probabilities as signaling correlations and organize them into a column stochastic matrix mathbfP where P(yx) is the element in the y^th row and x^th column. Hence mathbfP represents a classical channel with X inputs and Y outputs and we denote the set of all such classical channels as mathcalP^Xto Y.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The information capacity of a channel will typically be limited. In the one-shot setting, we can quantify this value by d, the number of distinct classical messages used. In a quantum system d corresponds to the Hilbert space dimension of encoded quantum states. For example, single bit or qubit communication corresponds to d=2, while for general d we specify a single dit or qudit of communication.","category":"page"},{"location":"background/signaling_correlations/#Code-Example:-The-LocalSignaling-Scenario","page":"Signaling Correlations","title":"Code Example: The LocalSignaling Scenario","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"To model such signaling devices, we apply the framework of BellScenario.jl. The signaling device is then described by the BellScenario.LocalSignaling scenario which specifies the number of inputs X, outputs Y and forward communication d.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 4    # num outputs\nd = 2    # bit or qubit signaling\n\nscenario = LocalSignaling(X, Y, d)","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Note that the constructed LocalSignaling type specifies the black-box configuration, but not whether classical or quantum signaling is used.","category":"page"},{"location":"background/signaling_correlations/#Classical-Channels","page":"Signaling Correlations","title":"Classical Channels","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"In a classical setting, a LocalSignaling scenario decomposes as follows:","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Alice (the transmitter) encodes input x into a single dit message mind.\nMessage m is noiselessly sent from Alice to Bob.\nBob (the receiver) decodes message m to  produce output y.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"To assist in this protocol, Alice and Bob can use shared randomness to coordinate their encoding and decoding maps. This noiseless one-way communication protocol is depicted in the following image.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Classical Signaling Device)","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"In the figure, T_lambda(mx) and R_lambda(ym) are the conditional probabilities for the transmitter and receiver. In fact, the transmitter and receiver can be represented as classical channels mathbfT_lambdainmathcalP^X to d and mathbfR_lambda in mathcalP^d to Y. Furthermore, Lambda denotes the sample space from which  shared random variable lambda is drawn with the probability q(lambda) where sum_lambdainLambda q(lambda) = 1. The classical signaling correlations produced in a LocalSignaling scenario decompose as","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P(yx) = sum_lambdainLambdaq(lambda)mathbfR_lambdamathbfT_lambda  = sum_lambdainLambdaq(lambda) sum_mindR_lambda(ym)T_lambda(mx)","category":"page"},{"location":"background/signaling_correlations/#Code-Example:-Classical-Signaling-Devices","page":"Signaling Correlations","title":"Code Example: Classical Signaling Devices","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The complete set of classical signaling correlations are denoted mathcalC_d^X to Y. Any classical channel mathbfP satisfies mathbfPinmathcalC_d^X to Ysubset mathcalP^X to Y. The set mathcalC_d^X to Y forms a convex polytope regarded as the signaling polytope. More details on the structure of the signaling polytope are found in the Signaling Polytopes section. In the BellScenario.jl framework a classical channel mathbfPinmathcalP^Xto Y is then represented by a BellScenario.AbstractStrategy type where a Strategy is simply a column stochastic map.","category":"page"},{"location":"background/signaling_correlations/#Code-Example:-Classical-Signaling-without-Shared-Randomness","page":"Signaling Correlations","title":"Code Example: Classical Signaling without Shared Randomness","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\nT = Strategy([1 0 1;0 1 0])    # transmitter channel\nR = Strategy([0 0;0 1;1 0])    # receiver channel\n\nP = *(R, T, scenario)    # `Strategy` matrix multiplication : P = R*T","category":"page"},{"location":"background/signaling_correlations/#Code-Example:-Classical-Signaling-with-Shared-Randomness","page":"Signaling Correlations","title":"Code Example: Classical Signaling with Shared Randomness","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# λ = 1 strategies\nT1 = Strategy([1 0 1;0 1 0])    # transmitter channel 1\nR1 = Strategy([0 0;0 1;1 0])    # receiver channel 1\n\n# λ = 2 strategies\nT2 = Strategy([0 0.5 1;1 0.5 0])    # transmitter channel 2\nR2 = Strategy([1 0;0 1;0 0])        # receiver channel 2\n\nΛ = [0.5, 0.5]    # shared random distribution\n\n# `Strategy` matrix multiplication : P = R*T\nP1 = *(R1, T1, scenario)\nP2 = *(R2, T2, scenario)\n\n# Convex combination of `P1` and `P2`\nStrategy(sum( Λ .* [P1, P2] ), scenario)","category":"page"},{"location":"background/signaling_correlations/#Quantum-Channels","page":"Signaling Correlations","title":"Quantum Channels","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"In a quantum setting a LocalSignaling scenario decomposes as follows:","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Alice uses a classical-quantum encoder Psi to transform input x into a quantum state rho_x.\nAlice sends rho_x to Bob through a quantum channel mathcalN.\nBob measures mathcalN(rho_x) with a positive operator-valued measure (POVM) Pi = Pi_y_yinmathcalY produce output y.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The amount of quantum communication is measured by the Hilbert space dimension of rho_x. Additionally, the quantum channel mathcalN performs a completely positive trace-preserving (CPTP) map on the density matrix of rho_x producing a new quantum states mathcalN(rho_x). This quantum communication scheme is depicted in the following figure.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Quantum Signaling)","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Note that the inputs and outputs are classical, hence, we discuss the classical channel mathbfP_mathcalN generated using quantum channel mathcalN. The signaling correlations of a quantum signaling device are then expressed","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P_mathcalN(yx) = textTrPi_y mathcalN(rho_x)","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"for a  given set  of quantum states rho_x_xinmathcalX and POVM Pi_y_yinmathcalY. The set of quantum channels generated for any choice of states and POVM is denoted mathcalQ_mathcalN^X to Y where mathbfP_mathcalN inmathcalQ_mathcalN^X to Ysubset mathcalP^X to Y. For example, a noiseless quantum channel mathcalN=textid_d where textid_d is the d times d identity matrix, the signaling correlations are constructed as","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P_textid_d(yx) = textTrPi_y rho_x","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"while the set of all noiseless channels is denoted mathcalQ_d^X to Y.","category":"page"},{"location":"background/signaling_correlations/#Code-Example:-Signaling-Over-a-Quantum-Channel","page":"Signaling Correlations","title":"Code Example: Signaling Over a Quantum Channel","text":"","category":"section"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"To numerically construct quantum signaling correlations, BellScenario.jl provides a quantum_strategy method. As input this method requires states and POVMs to be represented by QBase.States.AbstractDensityMatrix and QBase.Observables.AbstractPOVM as defined in the QBase.jl package.","category":"page"},{"location":"background/signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\nusing QBase\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # qudit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\nΨ = States.trine_qubits             # trine qubit states\nprintln(\"Ψ = \", Ψ, \"\\n\") # hide\nΠ = Observables.trine_qubit_povm    # trine qubit povm\nprintln(\"Π = \", Π, \"\\n\")\n\n# quantum signaling correlations for an ideal channel\nP = quantum_strategy(Π, Ψ, scenario)\nprintln(\"P = \", P,\"\\n\") # hide\n\n# quantum signaling correlations for a depolarizing channel\nμ = 0.5    # depolarization amount 0 ≤ μ ≤ 1\nP_N = quantum_strategy(Π, Channels.depolarizing.(Ψ, μ), scenario)\nprintln(\"P_N = \", P_N) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SignalingDimension","category":"page"},{"location":"#SignalingDimension.jl","page":"Home","title":"SignalingDimension.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Certify the classical simulation cost of black-box systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia software package is the companion piece to Certifying the Classical SImulation Cost of a Quantum Channel.","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SignalingDimension","category":"page"},{"location":"#SignalingDimension.SignalingDimension","page":"Home","title":"SignalingDimension.SignalingDimension","text":"The advent of quantum technology requires new figures of merit to compare the performance of quantum and classical systems. The signaling dimension quantifies the classical simulation cost of black-box devices. That is, it specifies the minimum amount of noiseless, classical communication needed to exactly simulate the input-output statistics of the device in question. The signaling dimension is discussed in greater detail in the Background section of this documentation.\n\nFeatures:\n\nTools to compute signaling correlations and polytopes (see Signaling Correlations and Signaling Polytopes).\nA catalog of Bell inequalities for witnessing signaling dimension (see Bell Inequalities).\nMethods to certify the signaling dimension of signaling systems (see Certifying Signaling Dimension).\n\n\n\n\n\n","category":"module"},{"location":"#Signaling-Polytope-Data","page":"Home","title":"Signaling Polytope Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our computed facets of the signaling polytope are found in the data/ directory. Please review the Computed Facets section for details regarding individual data sets.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Package Registration in Progress\nUntil SignalingDimension.jl is registered add the package typing ] to enter pkg> mode and enterpkg> add https://github.com/ChitambarLab/SignalingDimension.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install Julia: https://julialang.org/downloads/\nAdd the SignalingDimension.jl package (run from julia prompt):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SignalingDimension\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To run the examples, add the BellScenario.jl and QBase.jl dependencies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"BellScenario\")\njulia> using Pkg; Pkg.add(\"QBase\")","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"signaling_correlations.md\", \"signaling_dimension.md\", \"SignalingPolytope/overview.md\", \"SignalingPolytope/general_facets.md\", \"certifying_signaling_dimension.md\"]\nDepth = 2","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To reference this work, see CITATION.bib.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SignalingDimension.jl is released under the MIT License.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of SignalingDimension.jl was made possible by the advisory of Dr. Eric Chitambar and general support from the Physics Department at the University of Illinois Urbana-Champaign. Funding was provided by NSF Award 1914440.","category":"page"}]
}
