var documenterSearchIndex = {"docs":
[{"location":"certifying_signaling_dimension/#Certifying-Signaling-Dimension","page":"Certifying Signaling Dimension","title":"Certifying Signaling Dimension","text":"","category":"section"},{"location":"certifying_signaling_dimension/#Lower-Bounds","page":"Certifying Signaling Dimension","title":"Lower Bounds","text":"","category":"section"},{"location":"certifying_signaling_dimension/#Upper-Bounds","page":"Certifying Signaling Dimension","title":"Upper Bounds","text":"","category":"section"},{"location":"certifying_signaling_dimension/#Quantum-Channels","page":"Certifying Signaling Dimension","title":"Quantum Channels","text":"","category":"section"},{"location":"certifying_signaling_dimension/#Measurement-SDP-Optimization","page":"Certifying Signaling Dimension","title":"Measurement SDP Optimization","text":"","category":"section"},{"location":"signaling_correlations/#Signaling-Correlations","page":"Signaling Correlations","title":"Signaling Correlations","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The transmission of classical information from Alice to Bob can be described in the computational framework of BellScenario.jl. At the highest-level, a communication channel is a black-box connecting Alice to Bob.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Signaling Black-Box)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The black-box has a classical input xin mathcalX=n=12cdotsn and classical output yinmathcalY=n. Without making assumptions about the physical signals used to communicate, the behavior of the communication channel is characterized by its conditional probabilities P(yx) referred to as signaling correlations. These input-output correlations can be organized into a n times n column stochastic matrix mathbfP which is represented using children of the BellScenario.AbstractStrategy type. The set of all attainable communication channels is denoted mathcalP^n to n.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"To evaluate the performance of classical and quantum signaling, the amount communication must be taken into consideration. This communication process is described by the BellScenario.LocalSignaling scenario which specifies the number of inputs X, outputs Y and communication d.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # d-dit or d-qudit\n\nscenario = LocalSignaling(X, Y, d)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"Note that the LocalSignaling scenario type only specifies the black-box configuration.","category":"page"},{"location":"signaling_correlations/#Classical-Channels","page":"Signaling Correlations","title":"Classical Channels","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"When classical signals are used to communicate, the amount of communication is specified as a dit, the number of distinct messages, d, that can be transmitted. A dit is the generalization of a bit (d=2) where  n-bits of classical communication is equivalent to one dit withd = 2^n-1. Furthermore, shared randomness can be shared between Alice and Bob (transmitter and receiver).","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Classical Local Signaling Scenario)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"As depicted in the figure, Alice sends a classical message mind to Bob. The content of m is determined by the input xinn and the encoding strategy of the transmitter T_lambda(mx). Likewise, Bob's output yinn is derived from m using a decoding strategy of the receiver R_lambda(ym). The transmitter and receiver strategies are simply stochastic maps mathbfT_lambda in mathcalP^n to d and mathbfR_lambda in mathcalP^d to n  respectively. The sample space of the shared randomness is denoted Lambda where the shared random variable lambda in Lambda is weighted by the probability mmass function q(lambda) such that sum_lambdainLambda q(lambda) = 1. Alice and Bob both have access to lambda and therefore can condition their encoding and decoding strategies on this value.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The classical signaling correlations produced in a LocalSignaling scenario are constructed by","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P(yx) = sum_lambdainLambdaq(lambda) sum_mindR_lambda(ym)T_lambda(mx)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The complete set of classical signaling correlations are denoted mathcalC_d^n to n. Any classical local signaling strategy mathbfP satisfies mathbfPinmathcalC_d^n to nsubset mathcalP^n to n. The set mathcalC_d^n to n forms a convex polytope regarded as the signaling polytope. More details on the structure of the signaling polytope are found in the Signaling Polytope: Overview section.","category":"page"},{"location":"signaling_correlations/#Code-Example:-Classical-Signaling-without-Shared-Randomness","page":"Signaling Correlations","title":"Code Example: Classical Signaling without Shared Randomness","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # d-dit\n\nscenario = LocalSignaling(X, Y, d)\n\nT = Strategy([1 0 1;0 1 0])    # transmitter strategy\nR = Strategy([0 0;0 1;1 0])    # receiver strategy\n\nS = *(R, T, scenario)    # `Strategy` matrix multiplication : S = R*T","category":"page"},{"location":"signaling_correlations/#Code-Example:-Classical-Signaling-with-Shared-Randomness","page":"Signaling Correlations","title":"Code Example: Classical Signaling with Shared Randomness","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # d-dit\n\nscenario = LocalSignaling(X, Y, d)\n\n# λ = 1 strategies\nT1 = Strategy([1 0 1;0 1 0])    # transmitter strategy\nR1 = Strategy([0 0;0 1;1 0])    # receiver strategy\n\n# λ = 2 strategies\nT2 = Strategy([0 0.5 1;1 0.5 0])    # transmitter strategy\nR2 = Strategy([1 0;0 1;0 0])        # receiver strategy\n\nΛ = [0.5, 0.5]    # shared random distribution\n\n# `Strategy` matrix multiplication : S = R*T\nS1 = *(R1, T1, scenario)\nS2 = *(R2, T2, scenario)\n\n# Convex combination of `S1` and `S2`\nStrategy(sum( Λ .* [S1, S2] ), scenario)","category":"page"},{"location":"signaling_correlations/#Quantum-Channels","page":"Signaling Correlations","title":"Quantum Channels","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"When quantum signals are used to communicate, Alice uses a classical quantum encoder Psi to transform input x into a quantum state rho_x. Bob decodes the output y using a positive operator-valued measure (POVM) Pi = Pi_y_yinmathcalY. The amount of quantum communication is measured by the Hilbert space dimension of rho_x. During transmission, quantum states are subjected to processing and noise inherent to the signaling system. These effects are modeled by a quantum channel mathcalN which performs a completely positive trace-preserving (CPTP) map.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"(Image: Quantum Signaling)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The signaling correlations of a general quantum channel are then expressed","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P_mathcalN(yx) = textTrPi_y mathcalN(rho_x)","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"While for an ideal quantum channel, the signaling correlations are constructed as","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"P(yx) = textTrPi_y rho_x","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"The set of quantum strategies are denoted mathcalQ_mathcalN^n to n where mathbfP_mathcalN inmathcalQ_mathcalN^n to nsubset mathcalP^n to n.","category":"page"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"To compute quantum signaling correlations, BellScenario.jl provides a quantum_strategy method. As input this method requires states and POVMs to be represented by QBase.States.AbstractDensityMatrix and QBase.Obserbables.AbstractPOVM defined in the QBase.jl package","category":"page"},{"location":"signaling_correlations/#Code-Example:-Signaling-Over-Quantum-Channel","page":"Signaling Correlations","title":"Code Example: Signaling Over Quantum Channel","text":"","category":"section"},{"location":"signaling_correlations/","page":"Signaling Correlations","title":"Signaling Correlations","text":"using BellScenario\nusing QBase\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # d-dit\n\nscenario = LocalSignaling(X, Y, d)\n\nΨ = States.trine_qubits             # trine qubit states\nprintln(\"Ψ = \", Ψ, \"\\n\") # hide\nΠ = Observables.trine_qubit_povm    # trine qubit povm\nprintln(\"Π = \", Π, \"\\n\")\n\n# quantum signaling correlations for an ideal channel\nP = quantum_strategy(Π, Ψ, scenario)\nprintln(\"P = \", P,\"\\n\") # hide\n\n# quantum signaling correlations for a depolarizing channel\nμ = 0.5    # depolarization amount 0 ≤ μ ≤ 1\nP_N = quantum_strategy(Π, Channels.depolarizing.(Ψ, μ), scenario)\nprintln(\"P_N = \", P_N) # hide","category":"page"},{"location":"signaling_dimension/#Signaling-Dimension","page":"Signaling Dimension","title":"Signaling Dimension","text":"","category":"section"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The signaling dimension of a channel mathbfPinmathcalP^n to n is the smallest integer d such that mathbfP in mathcalC_d^n to n.","category":"page"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Since mathcalC_d^n to n is the set of classical channels using d-dit communication and shared randomness, the signaling dimension of a channel specifies the minimal amount of classical communication needed to simulate channel mathbfP. The signaling dimension is a device-independent characteristic of a channel because it can be computed from the channel correlations alone. This means that the signaling dimension can be used to quantify the performance of classical and quantum channels alike. Hence, the signaling dimension yields a","category":"page"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Let mathcalQ_d^N to n denote the set of signaling correlations over an ideal quantum channel on a d-dimensional Hilbert space. It was recently proven that mathcalQ_d^N to n subset mathcalC_d^n to n [Frenkel2015]. That is, one-shot classical communication using d messages and shared randomness can exactly simulate the correlations generated by ideal quantum communication over a d-dimensional Hilbert space.","category":"page"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"The signaling dimension is important because it provides a quantitative metric comparing quantum and classical signaling systems, the classical simulation cost. A classical simulation of a quantum system reproduces the signaling correlations of that system, hence, the quantum system and its classical simulation are operationally equivalent. Since classical resources are heavily used in industry, there is well-defined monetary value that can be placed on the use of classical resorces. Therefore, the classical simulation cost can help justify (or reject) the use of quantum technology for a particular task. Although, it should be noted that certain quantum properties such as no-cloning are not represented in the signaling correlations. These properties cannot be reproduced classically and can be deemed invaluable for certain tasks such as private key distribution.","category":"page"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"Computing the signaling dimension of communication channels requires a test to verify the inclusion (or exclusion) of a channel mathbfP in mathcalC_d^n to n. Within the framework of Bell scenarios, linear Bell inequalities serve as the bounds of classical correlations and therefore, provide a convenient test for inclusion within the signaling mathcalC_d^n to n. The BellScenario.LocalPolytope module provides tools for computing the bounds of the signaling polytope. However, these computation challenging and rapidly become infeasible. The polytope computations will be discussed in detail in the Signaling Polytope: Overview section.","category":"page"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"To bypass the challenges of polytope computations, lower and upper bounds can efficiently be placed on the signaling dimension. These device-independent tests certify the signaling dimension of channel and are discussed in more detail in the Certifying Signaling Dimension section.","category":"page"},{"location":"signaling_dimension/#References","page":"Signaling Dimension","title":"References","text":"","category":"section"},{"location":"signaling_dimension/","page":"Signaling Dimension","title":"Signaling Dimension","text":"[Frenkel2015]: Frenkel, Péter E., and Mihály Weiner. \"Classical information storage in an n-level quantum system.\" Communications in Mathematical Physics 340.2 (2015): 563-574.","category":"page"},{"location":"SignalingPolytope/overview/#Signaling-Polytope:-Overview","page":"Overview","title":"Signaling Polytope: Overview","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The signaling polytope is denoted mathcalC_d^n to n and represents the set of signaling correlations produced using one-way noiseless classical communication and shared randomness. The signaling polytope is a convex polyhedron and therefore, admits two equivalent descriptions.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Vertex Description: The convex-hull of a finite set of extreme-points mathcalV_d^n to nsubsetmathcalP_d^n to n.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"mathcalC_d^n to n = textConv(mathcalV_d^n to n)","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Half-space Description: The intersection of a finite set of half-spaces mathcalF_d^n to n.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"mathcalC_d^n to n = capmathcalF_d^n to n","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The BellScenario.LocalPolytope provides tools for computing each of these representations.","category":"page"},{"location":"SignalingPolytope/overview/#Vertices","page":"Overview","title":"Vertices","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"A signaling polytope vertex mathbfVinmathcalV_d^n to n must satisfy:","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"textRank(mathbfV) leq d\nElements V(yx) in 01 for all yinmathcalY and xinmathcalX","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Since the elements of a vertex are 0/1, they designate a BellScenario.DeterministicStrategy. However, DeterministicStrategy types contain redundant information because each of the columns in the matrix are normalized, sum_yin n P(yx) = 1. Therefore, the strategy can be represented in a \"normalized\" subspace where the n-th row of the matrix is removed. Additionally, the polytope transformation software used by the BellScenario.LocalPolytope module requires a vector input. A column-major vectorization of the strategy matrix is then used to represent vertices in the \"normalized\" subspace.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"In total, the number of vertices are counted by","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"mathcalV_d^n to n = sum_c=1^d leftX atop c rightbinomYcc","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"where   denotes Stirling's number of the second kind and binomnk denotes n choose k [DallArno2017]. Signaling polytope vertices can be counted using the BellScenario.LocalPolytope.num_vertices method and enumerated usig the BellScenario.LocalPolytope.vertices method.","category":"page"},{"location":"SignalingPolytope/overview/#Code-Example:-Counting-Vertices","page":"Overview","title":"Code Example: Counting Vertices","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"using BellScenario\n\nX = 4    # num inputs\nY = 4    # num outputs\nd = 2    # d-dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Count the number of vertices for the signaling polytope\nnum_vertices = LocalPolytope.num_vertices(scenario)","category":"page"},{"location":"SignalingPolytope/overview/#Code-Example:-Enumerating-Vertices","page":"Overview","title":"Code Example: Enumerating Vertices","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"using BellScenario\n\nX = 4    # num inputs\nY = 4    # num outputs\nd = 2    # d-dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\n# These vertices can be fed directly into polytope transformation methods.\nvertices = LocalPolytope.vertices(scenario)\n\n# Convert each vertex into a `DetermministicStrategy` matrix form.\ndeterministic_strategies = map(v -> convert(DeterministicStrategy, v, scenario), vertices)","category":"page"},{"location":"SignalingPolytope/overview/#Facets","page":"Overview","title":"Facets","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"A signaling polytope facet mathbfF in mathcalF_d^n to n is a half-space inequality represented by a tuple (gamma mathbfG) containing an inequality upper bound gamma and real ntimes n matrix mathbfGin mathbbR^ntimes n. A strategy matrix mathbfP can be verified against a half-space inequality mathbfF through the inner product","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"gamma geq langle mathbfG mathbfPrangle = sum_xyG_yxP(yx)","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"If the inequality is not satisfied, then mathbfP violates facet mathbfF and is not included in the signaling polytope.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"A facet of mathcalC_d^n to n must satisfy:","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"gamma geq langle mathbfG mathbfV rangle for all vertices mathbfV in mathcalV_d^n to n.\ngamma = langle mathbfG mathbfV rangle for at least n(n-1) affinely independent vertices mathbfV in mathcalV_d^n to n.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Within the context of Bell scenarios, facets are equivalent to tight Bell inequalities. Hence, their violation witnesses the use of resources of  greater operational value than the set of classical resources considered for the particular  signaling polytope mathcalC_d^n to n.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Since the vertices of of the signaling polytope have  0/1 elements, mathcalC_d^nto n is an integral polytope with rational facet inequality coefficients. Therefore, any facet inequality mathbfFinmathcalF_d^n to n can be expressed in terms of integer coefficients. Furthermore, the normalization constraints on strategies mathbfP in mathcalC_d^n to n allows matrix mathbfG to have non-negative entries and bound gamma to be positive.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"This standard form for a facet inequality is represented by the BellScenario.BellGame type. However, facets are initially computed in a vectorized form in the \"normalized\" subspace.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"warning: Performance of Facet Computations\nFacet computations fail to perform for large numbers of vertices and vertices with large dimension. The number of vertices scale exponentially with the number of inputs and outputs, while the dimension scales as n(n-1).","category":"page"},{"location":"SignalingPolytope/overview/#Code-Example:-Complete-Facet-Enumeration","page":"Overview","title":"Code Example: Complete Facet Enumeration","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"using BellScenario\n\nX = 3    # num inputs\nY = 3    # num outputs\nd = 2    # d-dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\nvertices = LocalPolytope.vertices(scenario)\n\n# Compute complete set of facets in \"normalized\" subspace.\nfacets = LocalPolytope.facets(vertices)[\"facets\"]\n\n# Convert each facet into `BellGame` form.\nbell_games = map( f -> convert(BellGame, f, scenario), facets)\n\n# printing γ ≥ G for each bell game\nfor bg in bell_games\n    println(bg.β, \" ≥ \", bg.game)\nend","category":"page"},{"location":"SignalingPolytope/overview/#Adjacency-Decomposition","page":"Overview","title":"Adjacency Decomposition","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The input and output values a signaling scenario are merely labels. Rearranging these labels cannot change the structure of the signaling correlations. Therefore, the signaling polytope is invariant to permutations of inputs and outputs[Rosset2014].","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The permutation symmetry of the signaling polytope indicates that there is vertex and facet transitivity. This means that any permutation of the columns or rows of a strategy or game matrix results in a new strategy or game indistinguishable from the original. Hence, there exists a canonical set of generator vertices and facets whose permutations describe the entire signaling polytope.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"Since the number of permutations scale as factorial of n and n, the set of generators is dramatic reduction in the number of total vertices and facets needed to describe the polytope. The canonical form of a generator facet or vertex is arbitrary and hence lexicographic normal form is used as consistent ordering of matrices.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The adjacency decomposition technique [Christof2001] exploits the permutation symmetry of a polytope to compute a canonical set of generator facets. This method greatly reduces the facet computation times and can be performed on signaling polytopes using the BellScenario.LocalPolytope.adjacency_decomposition method. Please refer to BellScenario.jl documentation for additional details on the arguments, outputs, and implementation of the adjacency decomposition algorithm.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The advantages of the adjacency decomposition technique:","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"The set of generator facets is much smaller than the complete set of facets reducing the amount of computation and size of output data.\nThe computation does not need to be run to completion because a new generator facet is computed each iteration of the algorithm.\nThe computation can be parallelized.","category":"page"},{"location":"SignalingPolytope/overview/#Code-Example:-Adjacency-Decomposition","page":"Overview","title":"Code Example: Adjacency Decomposition","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"using BellScenario\n\nX = 4    # num inputs\nY = 4    # num outputs\nd = 2    # d-dit signaling\n\nscenario = LocalSignaling(X, Y, d)\n\n# Compute vertices in the \"normalized\" subspace.\nvertices = LocalPolytope.vertices(scenario)\n\n# The adjacency decomposition requires a facet to seed the algorithm.\nfacet_seed = BellGame([1 0 0 0;0 1 0 0;0 0 1 0;0 0 0 1], 2)\n\n# Compute the complete set of generator facets\nadj_dict = LocalPolytope.adjacency_decomposition(vertices, facet_seed, scenario)\n\n# The generator facets are the keys of returned dictionary\nfor bell_game in keys(adj_dict)\n    println(bell_game.β, \" ≥ \", bell_game.game)\nend","category":"page"},{"location":"SignalingPolytope/overview/#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"[DallArno2017]: Dall’Arno, Michele, et al. \"No-hypersignaling principle.\" Physical Review Letters 119.2 (2017): 020401.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"[Rosset2014]: Rosset, Denis, Jean-Daniel Bancal, and Nicolas Gisin. \"Classifying 50 years of Bell inequalities.\" Journal of Physics A: Mathematical and Theoretical 47.42 (2014): 424022.","category":"page"},{"location":"SignalingPolytope/overview/","page":"Overview","title":"Overview","text":"[Christof2001]: Christof, Thomas, and Gerhard Reinelt. \"Decomposition and parallelization techniques for enumerating the facets of combinatorial polytopes.\" International Journal of Computational Geometry & Applications 11.04 (2001): 423-437.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SignalingDimension","category":"page"},{"location":"#SignalingDimension.jl","page":"Home","title":"SignalingDimension.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Certify the classical simulation cost of signaling systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia software package is the companion piece to Testing the Classical Simulation Cost of a Quantum Channel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SignalingDimension","category":"page"},{"location":"#SignalingDimension.SignalingDimension","page":"Home","title":"SignalingDimension.SignalingDimension","text":"Overview\n\nWith the advent of quantum technology, new figures of merit are needed to compare the performance of quantum and classical systems.\n\nThe signaling dimension quantifies the performance of a communication channel by the minimal amount of classical communication needed to simulate the channel.\n\nThe signaling dimension of a channel makes no assumptions of the underlying physics and is therefore, a device-independent measure applicable to quantum and classical systems alike.\n\nThis software provides tests that certify the signaling dimension of a channel.\n\nFeatures\n\nMethods to test the signaling dimension of a communication system.\nA catalog of Bell inequalities for witnessing signaling dimension.\nVerification of Bell inequalities.\n\n\n\n\n\n","category":"module"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia: https://julialang.org/downloads/\nAdd the SignalingDimension.jl package (run from julia prompt):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SignalingDimension\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add BellScenario.jl and QBase.jl dependencies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"BellScenario\")\njulia> using Pkg; Pkg.add(\"QBase\")","category":"page"},{"location":"#Signaling-Polytope-Data","page":"Home","title":"Signaling Polytope Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our computed facets of the signaling polytope are found in the data/ directory. Please review the Computed Facets section for details regarding individual data sets.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"signaling_correlations.md\", \"signaling_dimension.md\", \"SignalingPolytope/overview.md\", \"SignalingPolytope/general_facets.md\", \"certifying_signaling_dimension.md\"]\nDepth = 2","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of SignalingDimension.jl was made possible by the advisory of Dr. Eric Chitambar and general support from the Physics Department at the University of Illinois Urbana-Champaign. Funding was provided by NSF Award 1914440.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To reference this work, see CITATION.bib.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SignalingDimension.jl is released under the MIT License.","category":"page"},{"location":"SignalingPolytope/general_facets/#Signaling-Polytope:-Bell-Inequalities","page":"General Facets","title":"Signaling Polytope: Bell Inequalities","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"The Bell inequalities (facets) of the signaling polytope bound the signaling correlations for d-dit classical communication. If a channel mathbfPinmathcalP^n to n violates a Bell inequality mathbfFsupset mathcalC_d^n to n, then mathbfPnotinmathcalC_d^n to n. Therefore, the signaling dimension of mathbfP is greater than d, that is, kappa(mathbfP)  d.","category":"page"},{"location":"SignalingPolytope/general_facets/#Theoretical-Facets","page":"General Facets","title":"Theoretical Facets","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"We provide several tight Bell inequality which bound general signaling polytopes.","category":"page"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"non_negativity_game\nsuccess_game\nambiguous_game\nerror_game\ngeneralized_error_game\ncoarse_grained_input_ambiguous_game","category":"page"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.non_negativity_game","page":"General Facets","title":"SignalingDimension.non_negativity_game","text":"non_negativity_game( num_outputs :: Int64, num_inputs :: Int64 ) :: BellGame\n\nConstructs the non-negativity game for a channel with num_outputs and num_inputs.\n\nA DomainError is thrown if num_outputs or num_inputs is not greater than 1.\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.success_game","page":"General Facets","title":"SignalingDimension.success_game","text":"success_game( N :: Int64, d :: Int64 ) :: BellGame\n\nConstructs the success game bound for the N-d-N polytope.\n\nA DomainError is thrown if the following requirements aren't satisfied:\n\n`N > 2\nN > d > 1\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.ambiguous_game","page":"General Facets","title":"SignalingDimension.ambiguous_game","text":"ambiguous_game( N :: Int64, d :: Int64 ) :: BellGame\n\nConstructs the ambiguous game for the (N-1)-d-N polytope.\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nN ≥ 4\n(N - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.error_game","page":"General Facets","title":"SignalingDimension.error_game","text":"error_game( N :: Int64, d :: Int64, ε :: Int64 ) :: BellGame\n\nConstructs the error game bound for the N-d-N polytope. Input ε sets the size of the anti-distinguishability matrix block.\n\nA DomainError is thrown if the following requirements aren't satisfied:\n\nN ≥ 4\n(N - 2) ≥ d ≥ 2\n(N - d + 1) ≥ ε ≥ 3\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.generalized_error_game","page":"General Facets","title":"SignalingDimension.generalized_error_game","text":"generalized_error_game( N :: Int64, d :: Int64, k :: Int64 ) :: BellGame\n\nConstructs the generalized error game for the specified parameters:\n\nN is the number of outputs\nd is the signaling dimension\nk is the number of non-zero terms in each column\n\nA DomainError is satisfied if the following requirements aren't satisfied:\n\n(N - k) ≥ d ≥ 2\n(N - 1) ≥ k ≥ 1\nN ≥ 3\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.coarse_grained_input_ambiguous_game","page":"General Facets","title":"SignalingDimension.coarse_grained_input_ambiguous_game","text":"coarse_grained_input_ambiguous_game(\n    num_outputs :: Int64,\n    d :: Int64\n) :: BellGame\n\nConstructs a canonical form for a input coarse-grained ambiguous game.\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nnum_outputs ≥ 4\n(num_outputs - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#Affinely-Independent-Enumerations","page":"General Facets","title":"Affinely Independent Enumerations","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"To prove the tightness of the preceeding facet, a set of n(n-1) affinely independent vertices must be shown to satisfy gamma = langle mathbfG mathbfV rangle. These enumerations a demonstrated with the following methods.","category":"page"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"aff_ind_success_game_strategies\naff_ind_non_negativity_game_strategies\naff_ind_ambiguous_game_strategies\naff_ind_coarse_grained_input_ambiguous_game_strategies\naff_ind_error_game_strategies\naff_ind_generalized_error_game_strategies","category":"page"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_success_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_success_game_strategies","text":"aff_ind_success_game_strategies( N :: Int64, d :: Int64 ) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of deterministic, stochastic, N x N rank-d matrices with trace equal to d. These matrices are all vertices of the success game facet found on the signaling polytope where N describes the number of inputs and d describes the signaling dimension of the communication channel.\n\nA valid input requires N > 2 and N > d > 1.\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_non_negativity_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_non_negativity_game_strategies","text":"aff_ind_non_negativity_game_strategies(\n    num_outputs :: Int64,\n    num_inputs :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of deterministic, stochastic, num_outputs x num_inputs matrices that satisfy the non_negativity_game with equality.\n\nA valid input requires N > 2 and N > d > 1.\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_ambiguous_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_ambiguous_game_strategies","text":"aff_ind_ambiguous_game_strategies(\n    N :: Int64,\n    d :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of deterministic, stochastic, N x (N-1) rank-d strategies which saturate the ambiguous_game. The existence of the enumeration proves that the ambiguous game is a facet of the signaling polytope\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nN ≥ 4\n(N - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_coarse_grained_input_ambiguous_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_coarse_grained_input_ambiguous_game_strategies","text":"aff_ind_coarse_grained_input_ambiguous_game_strategies(\n    n :: Int64,\n    d :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of deterministic, stochastic, n x n rank-d strategies which saturate the coarse_grained_input_ambiguous_game. The existence of the enumeration proves that the input coarse-graining lifting mechanism produces facets of the signaling polytope.\n\nA DomainError is thrown if the inputs don't satisfy the following requirements:\n\nn ≥ 4\n(n - 2) ≥ d ≥ 2\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_error_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_error_game_strategies","text":"aff_ind_error_game_strategies(N :: Int64, d :: Int64, error_size :: Int64) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices for the error game. The vertices are N x N, rank-d, column stochastic matrices.\n\nValid inputs are N > 4, N-1 > d > 1, and N-d+1 ≥ error_size ≥ 3.\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#SignalingDimension.aff_ind_generalized_error_game_strategies","page":"General Facets","title":"SignalingDimension.aff_ind_generalized_error_game_strategies","text":"aff_ind_generalized_error_game_strategies(\n    N :: Int64, d :: Int64, k :: Int64\n) :: Vector{Matrix{Int64}}\n\nEnumerates an affinely independent set of vertices for the generalized error game. The vertices are N x binomial(N,k), rank-d, column stochastic matrices. This function is restricted to games where N = d + k.\n\nValid inputs are N ≥ 4, d ≥ 2, and k ≥ 2.\n\n\n\n\n\n","category":"function"},{"location":"SignalingPolytope/general_facets/#Verification","page":"General Facets","title":"Verification","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"Unit tests in [test/unit/affinely_independent_enumerations.jl] verify that each of these affinely independent enumerations scale across a wide range of scenarios.","category":"page"},{"location":"SignalingPolytope/general_facets/#Computed-Facets","page":"General Facets","title":"Computed Facets","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"Using the adjacency decomposition technique, we've computed a broad range of signaling polytope facets. Computed facets of the signaling polytope are found in the data/ directory.","category":"page"},{"location":"SignalingPolytope/general_facets/#Quick-Adjacency-Decompositions","page":"General Facets","title":"Quick Adjacency Decompositions","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"In the data/quick_adjacency_decomposition/ directory, the adjacency decomposition algorithm is used to find the generating facets of the signaling polytope. The polytope computation scripts are found in the script/quick_adjacency_decomposition/ directory. They are intended to run quickly on a laptop computer.","category":"page"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":"Data is provided in two formats:","category":"page"},{"location":"SignalingPolytope/general_facets/","page":"General Facets","title":"General Facets","text":".txt files are human readable\n.ieq file format readable by BellScenario.jl.","category":"page"},{"location":"SignalingPolytope/general_facets/#Complete-Polytopes","page":"General Facets","title":"Complete Polytopes","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/#Verification-2","page":"General Facets","title":"Verification","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/#adjacency","page":"General Facets","title":"adjacency","text":"","category":"section"},{"location":"SignalingPolytope/general_facets/#complete-computations","page":"General Facets","title":"complete computations","text":"","category":"section"}]
}
