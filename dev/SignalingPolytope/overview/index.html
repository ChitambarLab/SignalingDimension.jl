<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · SignalingDimension.jl</title><link rel="canonical" href="https://ChitambarLab.github.io/SignalingDimension.jl/SignalingPolytope/overview/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SignalingDimension.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">SignalingDimension.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../signaling_correlations/">Signaling Correlations</a></li><li><a class="tocitem" href="../../signaling_dimension/">Signaling Dimension</a></li><li><span class="tocitem">Signaling Polytope</span><ul><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Vertices"><span>Vertices</span></a></li><li><a class="tocitem" href="#Facets"><span>Facets</span></a></li><li><a class="tocitem" href="#Adjacency-Decomposition"><span>Adjacency Decomposition</span></a></li></ul></li><li><a class="tocitem" href="../general_facets/">General Facets</a></li></ul></li><li><a class="tocitem" href="../../certifying_signaling_dimension/">Certifying Signaling Dimension</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Signaling Polytope</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChitambarLab/SignalingDimension.jl/blob/master/docs/src/SignalingPolytope/overview.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Signaling-Polytope:-Overview"><a class="docs-heading-anchor" href="#Signaling-Polytope:-Overview">Signaling Polytope: Overview</a><a id="Signaling-Polytope:-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Signaling-Polytope:-Overview" title="Permalink"></a></h1><p>The <em>signaling polytope</em> is denoted <span>$\mathcal{C}_d^{n \to n&#39;}$</span> and represents the set of signaling correlations produced using one-way noiseless classical communication and shared randomness. The signaling polytope is a convex polyhedron and therefore, admits two equivalent descriptions.</p><ul><li><strong>Vertex Description:</strong> The convex-hull of a finite set of extreme-points <span>$\mathcal{V}_d^{n \to n&#39;}\subset\mathcal{P}_d^{n \to n&#39;}$</span>.</li></ul><p class="math-container">\[\mathcal{C}_d^{n \to n&#39;} = \text{Conv}(\mathcal{V}_d^{n \to n&#39;})\]</p><ul><li><strong>Half-space Description:</strong> The intersection of a finite set of half-spaces <span>$\mathcal{F}_d^{n \to n&#39;}$</span>.</li></ul><p class="math-container">\[\mathcal{C}_d^{n \to n&#39;} = \cap\{\mathcal{F}_d^{n \to n&#39;}\}\]</p><p>The <a href="https://chitambarlab.github.io/BellScenario.jl/stable/LocalPolytope/overview/#BellScenario.LocalPolytope"><code>BellScenario.LocalPolytope</code></a> provides tools for computing each of these representations.</p><h2 id="Vertices"><a class="docs-heading-anchor" href="#Vertices">Vertices</a><a id="Vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Vertices" title="Permalink"></a></h2><p>A signaling polytope vertex <span>$\mathbf{V}\in\mathcal{V}_d^{n \to n&#39;}$</span> must satisfy:</p><ul><li><span>$\text{Rank}(\mathbf{V}) \leq d$</span></li><li>Elements <span>$V(y|x) \in \{0,1\}$</span> for all <span>$y\in\mathcal{Y}$</span> and <span>$x\in\mathcal{X}$</span></li></ul><p>Since the elements of a vertex are 0/1, they designate a <a href="https://chitambarlab.github.io/BellScenario.jl/dev/BellScenario/strategies/#BellScenario.DeterministicStrategy"><code>BellScenario.DeterministicStrategy</code></a>. However, <code>DeterministicStrategy</code> types contain redundant information because each of the columns in the matrix are normalized, <span>$\sum_{y\in [n&#39;]} P(y|x) = 1$</span>. Therefore, the strategy can be represented in a <code>&quot;normalized&quot;</code> subspace where the <span>$n&#39;$</span>-th row of the matrix is removed. Additionally, the polytope transformation software used by the <code>BellScenario.LocalPolytope</code> module requires a vector input. A column-major vectorization of the strategy matrix is then used to represent vertices in the <code>&quot;normalized&quot;</code> subspace.</p><p>In total, the number of vertices are counted by</p><p class="math-container">\[|\mathcal{V}_d^{n \to n&#39;}| = \sum_{c=1}^d \left\{X \atop c \right\}\binom{Y}{c}c!,\]</p><p>where <span>$\{ \}$</span> denotes Stirling&#39;s number of the second kind and <span>$\binom{n}{k}$</span> denotes <span>$n$</span> <span>$choose$</span> <span>$k$</span> <sup class="footnote-reference"><a id="citeref-DallArno2017" href="#footnote-DallArno2017">[DallArno2017]</a></sup>. Signaling polytope vertices can be counted using the <a href="https://chitambarlab.github.io/BellScenario.jl/dev/LocalPolytope/vertices/#BellScenario.LocalPolytope.num_vertices"><code>BellScenario.LocalPolytope.num_vertices</code></a> method and enumerated usig the <a href="https://chitambarlab.github.io/BellScenario.jl/dev/LocalPolytope/vertices/#BellScenario.LocalPolytope.vertices"><code>BellScenario.LocalPolytope.vertices</code></a> method.</p><h3 id="Code-Example:-Counting-Vertices"><a class="docs-heading-anchor" href="#Code-Example:-Counting-Vertices">Code Example: Counting Vertices</a><a id="Code-Example:-Counting-Vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Example:-Counting-Vertices" title="Permalink"></a></h3><pre><code class="language-julia">using BellScenario

X = 4    # num inputs
Y = 4    # num outputs
d = 2    # d-dit signaling

scenario = LocalSignaling(X, Y, d)

# Count the number of vertices for the signaling polytope
num_vertices = LocalPolytope.num_vertices(scenario)</code></pre><pre class="documenter-example-output">88</pre><h3 id="Code-Example:-Enumerating-Vertices"><a class="docs-heading-anchor" href="#Code-Example:-Enumerating-Vertices">Code Example: Enumerating Vertices</a><a id="Code-Example:-Enumerating-Vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Example:-Enumerating-Vertices" title="Permalink"></a></h3><pre><code class="language-julia">using BellScenario

X = 4    # num inputs
Y = 4    # num outputs
d = 2    # d-dit signaling

scenario = LocalSignaling(X, Y, d)

# Compute vertices in the &quot;normalized&quot; subspace.
# These vertices can be fed directly into polytope transformation methods.
vertices = LocalPolytope.vertices(scenario)

# Convert each vertex into a `DetermministicStrategy` matrix form.
deterministic_strategies = map(v -&gt; convert(DeterministicStrategy, v, scenario), vertices)</code></pre><pre class="documenter-example-output">88-element Array{DeterministicStrategy,1}:
 [1 1 1 1; 0 0 0 0; 0 0 0 0; 0 0 0 0]
 [0 0 0 0; 1 1 1 1; 0 0 0 0; 0 0 0 0]
 [0 0 0 0; 0 0 0 0; 1 1 1 1; 0 0 0 0]
 [0 0 0 0; 0 0 0 0; 0 0 0 0; 1 1 1 1]
 [1 1 1 0; 0 0 0 1; 0 0 0 0; 0 0 0 0]
 [0 0 1 0; 1 1 0 1; 0 0 0 0; 0 0 0 0]
 [1 1 0 0; 0 0 1 1; 0 0 0 0; 0 0 0 0]
 [1 0 1 0; 0 1 0 1; 0 0 0 0; 0 0 0 0]
 [0 1 0 0; 1 0 1 1; 0 0 0 0; 0 0 0 0]
 [0 1 1 0; 1 0 0 1; 0 0 0 0; 0 0 0 0]
 ⋮
 [0 0 0 0; 0 0 0 0; 0 1 1 0; 1 0 0 1]
 [0 0 0 0; 0 0 0 0; 1 0 0 0; 0 1 1 1]
 [0 0 0 0; 0 0 0 0; 0 0 0 1; 1 1 1 0]
 [0 0 0 0; 0 0 0 0; 1 1 0 1; 0 0 1 0]
 [0 0 0 0; 0 0 0 0; 0 0 1 1; 1 1 0 0]
 [0 0 0 0; 0 0 0 0; 0 1 0 1; 1 0 1 0]
 [0 0 0 0; 0 0 0 0; 1 0 1 1; 0 1 0 0]
 [0 0 0 0; 0 0 0 0; 1 0 0 1; 0 1 1 0]
 [0 0 0 0; 0 0 0 0; 0 1 1 1; 1 0 0 0]</pre><h2 id="Facets"><a class="docs-heading-anchor" href="#Facets">Facets</a><a id="Facets-1"></a><a class="docs-heading-anchor-permalink" href="#Facets" title="Permalink"></a></h2><p>A signaling polytope facet <span>$\mathbf{F} \in \mathcal{F}_d^{n \to n&#39;}$</span> is a half-space inequality represented by a tuple <span>$(\gamma, \mathbf{G})$</span> containing an inequality upper bound <span>$\gamma$</span> and real <span>$n&#39;\times n$</span> matrix <span>$\mathbf{G}\in \mathbb{R}^{n&#39;\times n}$</span>. A strategy matrix <span>$\mathbf{P}$</span> can be verified against a half-space inequality <span>$\mathbf{F}$</span> through the inner product</p><p class="math-container">\[\gamma \geq \langle \mathbf{G}, \mathbf{P}\rangle = \sum_{x,y}G_{y,x}P(y|x).\]</p><p>If the inequality is not satisfied, then <span>$\mathbf{P}$</span> violates facet <span>$\mathbf{F}$</span> and is not included in the signaling polytope.</p><p>A facet of <span>$\mathcal{C}_d^{n \to n&#39;}$</span> must satisfy:</p><ul><li><span>$\gamma \geq \langle \mathbf{G}, \mathbf{V} \rangle$</span> for all vertices <span>$\mathbf{V} \in \mathcal{V}_d^{n \to n&#39;}$</span>.</li><li><span>$\gamma = \langle \mathbf{G}, \mathbf{V} \rangle$</span> for at least <span>$n(n&#39;-1)$</span> affinely independent vertices <span>$\mathbf{V} \in \mathcal{V}_d^{n \to n&#39;}$</span>.</li></ul><p>Within the context of Bell scenarios, facets are equivalent to tight Bell inequalities. Hence, their violation witnesses the use of resources of  greater operational value than the set of classical resources considered for the particular  signaling polytope <span>$\mathcal{C}_d^{n \to n&#39;}$</span>.</p><p>Since the vertices of of the signaling polytope have  0/1 elements, <span>$\mathcal{C}_d^{n\to n&#39;}$</span> is an integral polytope with rational facet inequality coefficients. Therefore, any facet inequality <span>$\mathbf{F}\in\mathcal{F}_d^{n \to n&#39;}$</span> can be expressed in terms of integer coefficients. Furthermore, the normalization constraints on strategies <span>$\mathbf{P} \in \mathcal{C}_d^{n \to n&#39;}$</span> allows matrix <span>$\mathbf{G}$</span> to have non-negative entries and bound <span>$\gamma$</span> to be positive.</p><p>This standard form for a facet inequality is represented by the <a href="https://chitambarlab.github.io/BellScenario.jl/dev/BellScenario/games/#BellScenario.BellGame"><code>BellScenario.BellGame</code></a> type. However, facets are initially computed in a vectorized form in the <code>&quot;normalized&quot;</code> subspace.</p><div class="admonition is-warning"><header class="admonition-header">Performance of Facet Computations</header><div class="admonition-body"><p>Facet computations fail to perform for large numbers of vertices and vertices with large dimension. The number of vertices scale exponentially with the number of inputs and outputs, while the dimension scales as <span>$n(n&#39;-1)$</span>.</p></div></div><h3 id="Code-Example:-Complete-Facet-Enumeration"><a class="docs-heading-anchor" href="#Code-Example:-Complete-Facet-Enumeration">Code Example: Complete Facet Enumeration</a><a id="Code-Example:-Complete-Facet-Enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Example:-Complete-Facet-Enumeration" title="Permalink"></a></h3><pre><code class="language-julia">using BellScenario

X = 3    # num inputs
Y = 3    # num outputs
d = 2    # d-dit signaling

scenario = LocalSignaling(X, Y, d)

# Compute vertices in the &quot;normalized&quot; subspace.
vertices = LocalPolytope.vertices(scenario)

# Compute complete set of facets in &quot;normalized&quot; subspace.
facets = LocalPolytope.facets(vertices)[&quot;facets&quot;]

# Convert each facet into `BellGame` form.
bell_games = map( f -&gt; convert(BellGame, f, scenario), facets)

# printing γ ≥ G for each bell game
for bg in bell_games
    println(bg.β, &quot; ≥ &quot;, bg.game)
end</code></pre><pre class="documenter-example-output">1 ≥ [0 0 0; 1 0 0; 1 0 0]
1 ≥ [1 0 0; 0 0 0; 1 0 0]
1 ≥ [0 0 0; 0 1 0; 0 1 0]
1 ≥ [0 1 0; 0 0 0; 0 1 0]
1 ≥ [0 0 0; 0 0 1; 0 0 1]
1 ≥ [0 0 1; 0 0 0; 0 0 1]
1 ≥ [0 0 1; 0 0 1; 0 0 0]
1 ≥ [0 1 0; 0 1 0; 0 0 0]
1 ≥ [1 0 0; 1 0 0; 0 0 0]
2 ≥ [0 0 1; 0 1 0; 1 0 0]
2 ≥ [0 1 0; 0 0 1; 1 0 0]
2 ≥ [0 0 1; 1 0 0; 0 1 0]
2 ≥ [0 1 0; 1 0 0; 0 0 1]
2 ≥ [1 0 0; 0 0 1; 0 1 0]
2 ≥ [1 0 0; 0 1 0; 0 0 1]</pre><h2 id="Adjacency-Decomposition"><a class="docs-heading-anchor" href="#Adjacency-Decomposition">Adjacency Decomposition</a><a id="Adjacency-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-Decomposition" title="Permalink"></a></h2><p>The input and output values a signaling scenario are merely labels. Rearranging these labels cannot change the structure of the signaling correlations. Therefore, the signaling polytope is invariant to permutations of inputs and outputs<sup class="footnote-reference"><a id="citeref-Rosset2014" href="#footnote-Rosset2014">[Rosset2014]</a></sup>.</p><p>The permutation symmetry of the signaling polytope indicates that there is vertex and facet transitivity. This means that any permutation of the columns or rows of a strategy or game matrix results in a new strategy or game indistinguishable from the original. Hence, there exists a canonical set of generator vertices and facets whose permutations describe the entire signaling polytope.</p><p>Since the number of permutations scale as factorial of <span>$n$</span> and <span>$n&#39;$</span>, the set of generators is dramatic reduction in the number of total vertices and facets needed to describe the polytope. The canonical form of a generator facet or vertex is arbitrary and hence lexicographic normal form is used as consistent ordering of matrices.</p><p>The adjacency decomposition technique <sup class="footnote-reference"><a id="citeref-Christof2001" href="#footnote-Christof2001">[Christof2001]</a></sup> exploits the permutation symmetry of a polytope to compute a canonical set of generator facets. This method greatly reduces the facet computation times and can be performed on signaling polytopes using the <a href="https://chitambarlab.github.io/BellScenario.jl/stable/LocalPolytope/adjacency_decomposition/#BellScenario.LocalPolytope.adjacency_decomposition"><code>BellScenario.LocalPolytope.adjacency_decomposition</code></a> method. Please refer to BellScenario.jl documentation for additional details on the arguments, outputs, and implementation of the adjacency decomposition algorithm.</p><p>The advantages of the adjacency decomposition technique:</p><ul><li>The set of generator facets is much smaller than the complete set of facets reducing the amount of computation and size of output data.</li><li>The computation does not need to be run to completion because a new generator facet is computed each iteration of the algorithm.</li><li>The computation can be parallelized.</li></ul><h3 id="Code-Example:-Adjacency-Decomposition"><a class="docs-heading-anchor" href="#Code-Example:-Adjacency-Decomposition">Code Example: Adjacency Decomposition</a><a id="Code-Example:-Adjacency-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Example:-Adjacency-Decomposition" title="Permalink"></a></h3><pre><code class="language-julia">using BellScenario

X = 4    # num inputs
Y = 4    # num outputs
d = 2    # d-dit signaling

scenario = LocalSignaling(X, Y, d)

# Compute vertices in the &quot;normalized&quot; subspace.
vertices = LocalPolytope.vertices(scenario)

# The adjacency decomposition requires a facet to seed the algorithm.
facet_seed = BellGame([1 0 0 0;0 1 0 0;0 0 1 0;0 0 0 1], 2)

# Compute the complete set of generator facets
adj_dict = LocalPolytope.adjacency_decomposition(vertices, facet_seed, scenario)

# The generator facets are the keys of returned dictionary
for bell_game in keys(adj_dict)
    println(bell_game.β, &quot; ≥ &quot;, bell_game.game)
end</code></pre><pre class="documenter-example-output">2 ≥ [1 0 0 0; 1 0 0 0; 0 1 0 0; 0 0 1 0]
2 ≥ [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]
1 ≥ [1 0 0 0; 1 0 0 0; 1 0 0 0; 0 0 0 0]
4 ≥ [2 0 0 0; 1 1 1 0; 0 2 0 0; 0 0 1 1]
4 ≥ [2 0 0 0; 1 1 1 0; 0 2 0 0; 0 0 2 0]
3 ≥ [1 1 0 0; 1 0 1 0; 0 1 1 0; 0 0 0 1]</pre><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DallArno2017"><a class="tag is-link" href="#citeref-DallArno2017">DallArno2017</a>Dall’Arno, Michele, et al. &quot;No-hypersignaling principle.&quot; Physical Review Letters 119.2 (2017): 020401.</li><li class="footnote" id="footnote-Rosset2014"><a class="tag is-link" href="#citeref-Rosset2014">Rosset2014</a>Rosset, Denis, Jean-Daniel Bancal, and Nicolas Gisin. &quot;Classifying 50 years of Bell inequalities.&quot; Journal of Physics A: Mathematical and Theoretical 47.42 (2014): 424022.</li><li class="footnote" id="footnote-Christof2001"><a class="tag is-link" href="#citeref-Christof2001">Christof2001</a>Christof, Thomas, and Gerhard Reinelt. &quot;Decomposition and parallelization techniques for enumerating the facets of combinatorial polytopes.&quot; International Journal of Computational Geometry &amp; Applications 11.04 (2001): 423-437.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../signaling_dimension/">« Signaling Dimension</a><a class="docs-footer-nextpage" href="../general_facets/">General Facets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 8 January 2021 22:48">Friday 8 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
